<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.56.3" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>valar morghulis | we r here because we r not free</title>
    <meta property="og:title" content="valar morghulis | we r here because we r not free">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="golang,go语言,go语言笔记,rust,博客,项目管理,python,软件架构,公众号,小程序,区块链">
    <meta name="description" content="专注于IT互联网，包括但不限于Go语言(golang)、Rust、Android、Ios、Python、项目管理、抖音分析、软件架构、区块链等">
    <meta property="og:url" content="https://efvhi.github.io/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml+xml" href="https://efvhi.github.io/index.xml" title="valar morghulis" />
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="https://efvhi.github.io">
                            valar morghulis
                        </a>
                    </h1>
                
                <p class="description">we r here because we r not free</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://efvhi.github.io">首页</a>
                    
                    <a  href="https://efvhi.github.io/books/" title="随笔">随笔</a>
                    
                    <a  href="https://efvhi.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://efvhi.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/rust-macro/" title="Rust Macro" >Rust Macro</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月12日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                宏与函数的区别  从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 元编程（metaprogramming）。元编程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数的角色。但宏有一些函数所没有的附加能力。
一个函数标签必须声明函数参数个数和类型。相比之下，宏只接受一个可变参数：用一个参数调用 println!(&ldquo;hello&rdquo;) 或用两个参数调用 println!(&ldquo;hello {}&rdquo;, name) 。而且，宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。因为函数是在运行时被调用，同时 trait 需要在运行时实现，所以函数无法像宏这样。
实现一个宏而不是函数的消极面是宏定义要比函数定义更复杂，因为你正在编写生成 Rust 代码的 Rust 代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/rust-macro/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/money-of-soul/" title="[C]THE MONEY OF SOUL AND POSSIBILITY CONTROL" >[C]THE MONEY OF SOUL AND POSSIBILITY CONTROL</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年8月10日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E9%9A%8F%E7%AC%94">随笔</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                现在 还是 有着无尽可能的未来 更重要？
背景概述 「金融街」, 是一个由 Midas 银行管理的虚拟异空间，它以现实社会中人们的未来为依托而存在。对应现实中每一个大的金融区都有一条金融街，共有 10 个。每一个金融街中心都矗立着一个「Midas 印钞机」 能够吸收现实社会中人们的未来，以此印刷出希冀的金钱，即「Midas 币」。Midas 币会流入现实社会中，与实际货币混在一起正常使用。由于金融街外的人们无法分辨，从而实现金融街对现实社会的影响（控制）。
不管是普通人还是国家层面其实都在透支未来，肆意透支的结果就是欲望无限放大, 伴随而来的基本是惨痛的结局。……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/money-of-soul/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/pow-pos-dpos-paxos-raft/" title="区块链共识算法和普通数据库共识算法的差异" >区块链共识算法和普通数据库共识算法的差异</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年6月21日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E6%8A%80%E6%9C%AF">技术</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                拜占庭将军问题  一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。
系统的问题在于，将军中可能出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。
由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。
假使那些忠誠（或是沒有出錯）的將軍仍然能通過多數決定來決定他們的戰略，便稱達到了拜占庭容错。在此，票都會有一個預設值，若訊息（票）沒有被收到，則使用此預設值來投票。
上述的故事對映到計算機系統裡，將軍便成了計算機，而信差就是通訊系統。雖然上述的問題涉及了電子化的決策支援與資訊安全，卻沒辦法單純的用密碼學與數位簽章來解決。因為电路错误仍可能影響整個加密過程，這不是密碼學與數位簽章演算法在解決的問題。因此計算機就有可能將錯誤的結果送出去，亦可能導致錯誤的決策。
 上述引用自 wiki。
paxos, raft, pow, pos, dpos&hellip; 无论是 Paxos 还是 Raft 其实都只能解决非拜占庭将军容错的一致性问题，不能够应对分布式网络中出现的极端情况，但是这在传统的分布式系统都不是什么问题，无论是分布式数据库还是消息队列集群，它们内部的节点并不会故意的发送错误信息，在类似系统中，最常见的问题就是节点失去响应或者失效，所以它们在这种前提下是有效可行的，也是充分的。……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/pow-pos-dpos-paxos-raft/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/ipfs-dht/" title="Ipfs Dht 分布式哈希表" >Ipfs Dht 分布式哈希表</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年6月2日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E6%8A%80%E6%9C%AF">技术</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                分布式哈希表 哈希表把所有的东西都存储在一台机器上，当这台机器坏掉了之后，所存储的东西就全部消失了。分布式哈希表可以把一整张哈希表分成若干个不同的部分，分别存储在不同的机器上，这样就降低了数据全部被损坏的风险。
分布式哈希表通常采用一致性哈希函数来对机器和数据进行统一运算。对机器（通常是其IP地址）和数据（通常是其KEY值）进行统一的运算，把他们全都映射到一个地址空间中。假设有一个一致性哈希函数可以把一个值映射到32bit的地址空间中，从0一直到2^32 – 1。我们用一个圆环来表示这个地址空间。
假设有N台机器，那么hash()就会把这N台机器映射到这个环的N个地方。然后我们把整个地址空间进行一下划分，使每台机器控制一个范围的地址空间。这样，当我们向这个系统中添加数据的时候，首先使用hash()函数计算一下这个数据的index，然后找出它所对应的地址在环中属于哪个地址范围，我们就可以把这个数据放到相应的机器上。这样，就把一个哈希表分布到了不同的机器上。如下图所示：
这里蓝色的圆点表示机器，红色的圆点表示某个数据经过hash()计算后所得出的地址。
在这个图中，按照逆时针方向，每个机器占据的地址范围为从本机器开始一直到下一个机器为止。用顺时针方向来看，每个机器所占据的地址范围为这台机器之前的这一段地址空间。图中的虚线表示数据会存储在哪台机器上。
IPFS 貌似用的是 dht 的变种 Kademlia DHT  KAD网络对DHT有较大改进，一个新来的网络节点在初次连接到网络时会分配到一个ID，每个节点自身维护一个路由表和一个DHT，路由表保存网络中一部分节点的连接信息，DHT则用于存放文件信息。从上可以看出，KAD由两部分组成：
 路由表 DHT  细节过于复杂没空研究……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/ipfs-dht/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/distributed-protol-paxos-raft/" title="分布式协议 Paxos Raft" >分布式协议 Paxos Raft</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年5月26日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E6%8A%80%E6%9C%AF">技术</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                谈分布式协议 先把 CAP 原则祭出来.
 Consistency 一致性、 Availability 高可用性、 Partition tolerance 分区容错性  分布式系统中只能满足其中两项，这是 由CAP 理论得出的结论。
Paxos 在 paxos 算法中，分为 4 种角色：……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/distributed-protol-paxos-raft/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/go-mircro-design/" title="Go Mircro - 架构与微服务的设计模式" >Go Mircro - 架构与微服务的设计模式</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年5月21日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E6%8A%80%E6%9C%AF">技术</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                微服务 微服务其实是业务 模块化 的概念, 类似于编程的时候把一个业务 函数 模块化一样。
micro 中各种基础组件  Go Micro 是一个用 golang 编写的，插件化的 RPC 框架。它提供了基础的库，比如服务发现、客户端负载均衡、编解码、同步异步通信等。 Micro API 是一个 API 网关，用于将外部的 HTTP 请求路由到内部的 micro 服务上。它有单一的接入点，可以通过反向代理或者 http 转换成 RPC 来访问。 Micro Web 是一个 web 仪表盘，也是作为 micro web 应用的反向代理。我们相信 web 应用也应该是一个微服务，在微服务世界里也应该是第一等公民。它表现的很像 Micro API 但也有单独的特性比如 websocket。 Micro Sidecar 使用 http 服务，提供了 go-micro 的所有特性。虽然我们喜欢 golang 来构建微服务，但你也许想使用其他语言。所以 Sidecar 提供了一种其他语言的应用接入 Micro 世界的方式。 Micro CLI 是一个简单直接的命令行接口，用于与你的服务交互。他也可以使用你的 Sidecar 作为代理来连接服务。  API + GRPC + 注册发现 http 请求 + grpc 内部服务互相通讯 是连接 客户端 和 各种微服务的方式, 其中微服务相互进行数据交换离不开服务的注册和发现，如 consul， 提供 dns、负载均衡等等功能.……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/go-mircro-design/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/ipfs-files-storage/" title="IPFS 文件存储备份的问题" >IPFS 文件存储备份的问题</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年5月12日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                IPFS网络上同样的文件只有一份 IPFS本质上就是为了解决文件过度冗余问题。如果把人们都有的某个文件，做一次hash计算，只字不差的两个文件hash值相同。哪怕改动一个字，都是一个新版本，hash值都不同。只需要使用相同的hash值，就可以访问那个文件，这个hash值就是文件的地址。这个IPFS网络上同样的hash对应的文件只会保存一份。
IPFS系统可靠，但是有很小概率可能会造成用户文件的丢失 ipfs 上文件永久丢失的可能性非常低，如果持续付费的话，理论上只要还有节点存在文件就可以永久保存。
IPFS系统采用了的冗余备份技术是Erasure coding，简单讲：n份原始数据，增加m份校验数据，此时可以通过 n+m份数据中的任意n份数据来恢复原始数据，也就是可容忍的最大失效的数据数量为m。例如，如果想容错4个盘，采用n+4模式。传统的 RAID6 允许两个盘失效，对应 EC就是 n+2模式。EC目前在分布式存储上的应用越来越广。 IPFS允许用户指定 f(n, m) 参数n和m，来增加数据存储的安全性，如果想数据存储更加安全，可以采用增加m的方式，当然，这样做所付的费用也就相应的增加，一切取决于用户。 IPFS系统有自动修复存储的功能，如果系统检测到某些数据有丢失，会启动修复，来恢复到原来的n+m模式。IPFS把整个系统的存储统一调度，所以IPFS自带容灾备份功能。……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/ipfs-files-storage/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/sync-in-game/" title="网络游戏的同步" >网络游戏的同步</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年4月21日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E6%8A%80%E6%9C%AF">技术</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                概述 多人实时联机游戏中最重要的问题，所有客户端的表现（数据 (动作、状态) ）需要一致。将游戏大致分为 mmorpg 和 moba 类型分析选用不同的解决方案，《冒险岛》、《魔兽世界》采用的是 mmorpg 适用的状态同步，《王者荣耀》、《绝地求生》使用的帧同步。不过在实际实现的过程可能会有特殊的一些处理，混合一些方案来对反外挂和优化体验作出折中。状态同步和帧同步其实各有优缺点，并不是某一项方案一定能够取代另一项方案，弱交互不涉及多人同屏或者是《炉石传说》一类的游戏采用状态同步的方式就能满足需求了，当游戏类型对实时性要求很高时（比如，实时格斗、体育竞技类游戏（NBA2K）），帧同步可能就是最好的方案了。
常用解决方案 对比 状态同步 游戏逻辑均在服务端进行处理运算，再将结果再广播给相关客户端。服务端的计算量大、客户端只需要接收对应数据做好刷新。 重点 是要做好 差异更新，也就是某一类数据不必要采用全量数据发送给客户端进行同步（如背包物品数据）。至于模式基本是 req/resp, pub/sub 模式.……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/sync-in-game/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/react-context-api/" title="React Context Api" >React Context Api</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年4月20日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E5%89%8D%E7%AB%AF">前端</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                最新版 React Context API 官方释义
 The vast majority of applications do not need to use context.
If you want your application to be stable, don’t use context.……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/react-context-api/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://efvhi.github.io/post/rust-match/" title="Rust Match" >Rust Match</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年4月8日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="https://efvhi.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                rust 的 match 初看类似 switch，但是提供了更加强大的功能.
简单例子 enum Coin { Penny, Nickel, Dime, Quarter, } fn value_in_cents(coin: Coin) -&gt; u32 { match coin { Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, } }  提供模式匹配 struct Point { x: i64, y: i64, } let point = Point { x: 0, y: 0 }; match point { Point { x, y } =&gt; println!……
                            </div>
                            <p class="readmore"><a href="https://efvhi.github.io/post/rust-match/">阅读全文</a></p>
                        </article>
                    
                    



<ol class="page-navigator">
    

    
    <li  class="current">
        <a href="https://efvhi.github.io/">1</a>
    </li>
    
    <li >
        <a href="https://efvhi.github.io/page/2/">2</a>
    </li>
    
    <li >
        <a href="https://efvhi.github.io/page/3/">3</a>
    </li>
    

    
    <li class="next">
        <a href="https://efvhi.github.io/page/2/">下一页</a>
    </li>
    
</ol>



                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://efvhi.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://efvhi.github.io/post/rust-macro/" title="Rust Macro">Rust Macro</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/money-of-soul/" title="[C]THE MONEY OF SOUL AND POSSIBILITY CONTROL">[C]THE MONEY OF SOUL AND POSSIBILITY CONTROL</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/pow-pos-dpos-paxos-raft/" title="区块链共识算法和普通数据库共识算法的差异">区块链共识算法和普通数据库共识算法的差异</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/ipfs-dht/" title="Ipfs Dht 分布式哈希表">Ipfs Dht 分布式哈希表</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/distributed-protol-paxos-raft/" title="分布式协议 Paxos Raft">分布式协议 Paxos Raft</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/go-mircro-design/" title="Go Mircro - 架构与微服务的设计模式">Go Mircro - 架构与微服务的设计模式</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/ipfs-files-storage/" title="IPFS 文件存储备份的问题">IPFS 文件存储备份的问题</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/sync-in-game/" title="网络游戏的同步">网络游戏的同步</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/react-context-api/" title="React Context Api">React Context Api</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/post/rust-match/" title="Rust Match">Rust Match</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://efvhi.github.io/categories/%E5%89%8D%E7%AB%AF/">前端(1)</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链(2)</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/categories/%E6%8A%80%E6%9C%AF/">技术(10)</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库(1)</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言(7)</a>
    </li>
    
    <li>
        <a href="https://efvhi.github.io/categories/%E9%9A%8F%E7%AC%94/">随笔(3)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://efvhi.github.io/tags/channel/">channel</a>
    
    <a href="https://efvhi.github.io/tags/context-api/">context-api</a>
    
    <a href="https://efvhi.github.io/tags/cpp/">cpp</a>
    
    <a href="https://efvhi.github.io/tags/createremotethread/">createremotethread</a>
    
    <a href="https://efvhi.github.io/tags/dpos/">dpos</a>
    
    <a href="https://efvhi.github.io/tags/elasticsearch/">elasticsearch</a>
    
    <a href="https://efvhi.github.io/tags/gc/">gc</a>
    
    <a href="https://efvhi.github.io/tags/gil/">gil</a>
    
    <a href="https://efvhi.github.io/tags/go/">go</a>
    
    <a href="https://efvhi.github.io/tags/goroutine/">goroutine</a>
    
    <a href="https://efvhi.github.io/tags/hash/">hash</a>
    
    <a href="https://efvhi.github.io/tags/ipfs/">ipfs</a>
    
    <a href="https://efvhi.github.io/tags/k8s/">k8s</a>
    
    <a href="https://efvhi.github.io/tags/lambda/">lambda</a>
    
    <a href="https://efvhi.github.io/tags/match/">match</a>
    
    <a href="https://efvhi.github.io/tags/micro/">micro</a>
    
    <a href="https://efvhi.github.io/tags/minikube/">minikube</a>
    
    <a href="https://efvhi.github.io/tags/pos/">pos</a>
    
    <a href="https://efvhi.github.io/tags/pow/">pow</a>
    
    <a href="https://efvhi.github.io/tags/proxy-setting/">proxy-setting</a>
    
    <a href="https://efvhi.github.io/tags/python/">python</a>
    
    <a href="https://efvhi.github.io/tags/react/">react</a>
    
    <a href="https://efvhi.github.io/tags/rust/">rust</a>
    
    <a href="https://efvhi.github.io/tags/select/">select</a>
    
    <a href="https://efvhi.github.io/tags/smtp/">smtp</a>
    
    <a href="https://efvhi.github.io/tags/web/">web</a>
    
    <a href="https://efvhi.github.io/tags/windows/">windows</a>
    
    <a href="https://efvhi.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">共识算法</a>
    
    <a href="https://efvhi.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
    
    <a href="https://efvhi.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a>
    
    <a href="https://efvhi.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
    
    <a href="https://efvhi.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
    
    <a href="https://efvhi.github.io/tags/%E5%90%8C%E6%AD%A5/">同步</a>
    
    <a href="https://efvhi.github.io/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/">帧同步</a>
    
    <a href="https://efvhi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    
    <a href="https://efvhi.github.io/tags/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/">状态同步</a>
    
    <a href="https://efvhi.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/">网络游戏</a>
    
    <a href="https://efvhi.github.io/tags/%E8%A7%82%E5%90%8E%E6%84%9F/">观后感</a>
    
    <a href="https://efvhi.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%B3%A8%E5%85%A5/">远程注入</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://efvhi.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://efvhi.github.io">valar morghulis By efvhi</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>







</body>
</html>
